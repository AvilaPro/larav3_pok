1. Con composer: composer create-project --prefer-dist laravel/laravel "nombre"
2. Con php artisan list   Se puede ver una lista de los comandos disponibles con artisan
2.1  Escribiendo cualquiera de los comandos listados le podemos pasar el flag "-h" y con ello obtendremos mas claridad del que 
hace cada comando y que dato espera.
2.2 Como por ejemplo: php arisan make:controller -h    Este serviria para ver la ayuda de ese comando.
3. Podemos darle nombre a nuestra aplicacion a traves del comando php artisan app:name "nombre"
3.1 Si al ejecutar el comando anterior da el siguiente mensaje: "There are no commands defined in the "app" namespace" 
deberas solucionarlo con lo siguiente: composer require andrey-helldar/laravel-app --dev (y con esto ya puedes repetir 
el punto 3.)
4. Cambiar dentro de config/app.php modificar el time zone por: America/Caracas (asi en mi caso)
5. Alli mismo cambiar el idioma: 'locale' => 'es,
6. Ahora para que exista el idioma espanol dentro de nuestro proyexto debemos ir a resorces/lang/ crear una nueva 
carpeta llamado "es" alli crear cada una de los archivos encontrados en la carpeta "en" y sacando del repositorio 
(https://github.com/caouecs/Laravel-lang) entramos a src/ y alli buscamos es/ y vamos copiando la informacion en los 
archivos requeridos.
7.Recordar que HTTP es el protocolo de comunicacion que permite las transferencias de informacion en la WWW World Wide Web
La Http define una serie de metodos para poder hacer uso de los recursos disponibles, entre estos metodos esta GET. El GET solicita
una representaccion del recurso solicitado. Esta POST el cual envia los datos para que sea procesados por el recurso.
Otro metodo es el PUT / PATCH se utilizan para actualizar un recuros especifico. Tambien esta el DELETE que borra un recurso especifico.
8.ROUTES Las Rutas y su importancia.
En la carpeta "routes" tenemos una ruta llamada web.php.
Si escribimos en la consola php artisan serve nos cargara la vista en la ruta de la ip de laravel
Como podemos crear nuestras propia ruta? Pues en el archivo mecionado se copia lo siguiente:
Route:: con el verbo HTTP get y un nombre a esa ruta, dentro de los parametros del get podemos colocar uestra closure que no es mas que una funcion.
Queda asi: Route::get('/nombre_ruta', function(){
    return 'Hello World, es mi primera ruta :P';
});
Podemos ver esta nueva ruta colocandola en el navegador.
Con 127.0.0.1:8000/nombre_ruta
Tambien podemos recibir informacion como parametro dentro de nuestra ruta
Ruta con parametro: 
Route::get('/name/{name}', function($name){
    return 'Hola soy '. $name . ' '. $lastname;
});
para poder accesar correctamente a las rutas que reciben parametros debemos ingresar todos los parametros que le pensamos pasar.
Sin embargo podemos colocar valores por defecto a los parametros e indicar que dichos parametros son opcionales.
Como se hace eso? Pues escribiendo como sigue:
Route::get('/name/{name}/lastname/{lastname?}', function($name, $lastname = null){
    return 
});
Aqui el parametro name es obligatorio por lo que debe pasarse obligatoriamente y el parametro lastname no es obligatorio y por ende se le da un posible valor por defecto (en este caso null)
9. CONTROLLER Controladores
Los controladores se almacenan en la carpeta App/Http/Controllers
Alli se alamacenan los controladores
Para crear un nuevo controlador hay dos maneras: Manual y artisan
Manual: Vamos a la carpeta y manualmente creamos un archivo .php que sera nuestro controlador.
Ej: PruebaController.php
<?php

namespace LaraPok\Http\Controllers;

use LaraPok\Http\Controllers\Controller; //Por eso de la erencia se incluye esto

class PruebaController extends Controller{ //Recordar que esta clase hereda de Controller
    /* public function prueba(){
        return 'Estoy dentro de PruebController XD'; 
    Con este verificamos que entre correctamente a la funcion y al controlador*/
    public function prueba($param){
        return 'Estoy dentro de PruebController recibo este parametro '.$param;
        //esta func ya recibe parametros que se pueden pasar por el metodo get de la ruta.
    }
}
Como podemos usar este controlador?
Pues vamos a las rutas y hacemos los siguiente en el archivo web.php
//Route::get('prueba', 'PruebaController@prueba'); //paso 1 cap9
//Aqui como primer param se incluye la palabra con que accedere
//en este caso prueba, luego separado por una coma ','
//el nombre del controladora y con un '@' colocamos la funcion que debera ejecutarse
Route::get('prueba/{name}', 'PruebaController@prueba'); //paso2 cap9
//Aqui se le pasa por parametro si se desea un valor que se manejara en le controlador
10. CONTROLADORES Crear un enrutado Rest Full
Esto de REST Full se refiere a un end-point que implementa REST. REST es o se define un conjunto 
de principios arquitectónicos por los que se pueden diseñar servicios Web que se centran en 
los recursos de un sistema, lo que incluye la forma en que los estados de los recursos se 
dirigen y transfieren a través de HTTP por un amplio rango de clientes que están escritos en 
diferentes lenguajes.
Para empezar a trabajar con Rest en laravel podemos aprovechar la herramienta de 
laravel: Resource Controller
el comando es de terminal: php artisan make:controller TrainerController --resource
En nuestro caso fue ese porque es el controlador que se usara para cada "entrenador" Poke.
Este controlador se encuentra en la ruta especificada que hablamos en el punto 9.
    App/Http/Controllers
En este controlador creado con artisan ya estara completamente el CRUD creado.
Podemos crear la ruta del mismo en nuestro archivo web.php como sigue:
    Route::resource('trainers','TrainerController');
    //Con esta ruta definida sabremos que tenemos acceso a nuestro controlador. //cap 10
    //Como lo sabemos? Pues es lo que esta expuesto en la documentacion de laravel en #Resource Controller
Aqui dejo al URl actual de la documentacion: https://laravel.com/docs/6.x/controllers#resource-controllers
Tambien dentro de nuestro controlador creado en el index colocamos esto para probar que funciona:
 return 'Hola desde el controlador Trainers';
11. VIEWS Vistas
Una vista es la capa de presentacion en como mostramos informacion a un usuario.
Como deseamos tener una vista para el registro de un trainer debemos crearla y ademas
invocarla desde el controlador de trainers.
    En TrainerController en la funcion create() retornaremos la vista para crear dicho trainer.
    En la carpeta de resources/views/ crearemos una subcarpeta para todo lo que tenga que ver con
los trainer. Dentro crearemos el archivo create.blade.php y en el controlador le indicaremos que
el debera mostrar dicha vista de la siguiente forma: return view('trainers.create');
En nuestra vista (create.blade.php) creamos la estructura html que vamos a mostrar. Ademas podemos
linkear el Bootstrap CDN para que sea mas facil crear la estructura.
    Para obtener el Bootstrap CDN: https://getbootstrap.com/docs/4.4/getting-started/introduction/
    Si seguimos los pasos y las instrucciones alli dadas nos daremos cuenta que debemos incluir
    un <link> con  la inclusion de Bootstrap y unos scripts que incluiran JS, tal como lo indica la nota Bootstrap:
    "Muchos de nuestros componentes requieren el uso de JavaScript para funcionar. Específicamente, requieren jQuery , Popper.js y nuestros propios complementos de JavaScript. Coloque los siguientes <script>mensajes de correo cerca del final de sus páginas, justo antes de la </body>etiqueta de cierre , para habilitarlos. jQuery debe venir primero, luego Popper.js, y luego nuestros complementos de JavaScript."
12. BLADE
Blade es una herramienta que implementa laravel para crear plantillas dentro sus aplicaciones.
Para trabajar con Blade basta con conocer sus directivas.
Primero se recomienda crear una carpeta dentro de views llamada layouts/
Alli podemos crear nuestras clases padres de plantillas blade
    Para establecer directivas de clase padre se usa la directiva @yield('nombre') 
    Para que una plantilla pueda ser usada en otra vista se usa la directiva @extends('layouts.nameLayout')
    Para introducir contenido html a la directiva padre se usa la directiva @section('nameLayout')
Dentro se escribe el html a ser usado
Se cierra con un @endsection
Nota: no todas las directivas @section ameritan ser abiertas y cerradas, solo se cierran aquellas que contengan estructura html
13. HTTP Requests
Los Requests es el servicio de poder ejecutar en si en CRUD.
Para nuestro ejemplo vamos a crear el nuevo Trainer. Para ello debemos englobar lo que hemos creado en la vista create dentro de un form.
Como sigue: 
    <form class="form-group" action="/trainers" method="POST">
La clase es la de Bootstrap, el metodo es POST y el action tal como se ve en la documentacion 
de laravel es la ruta que ah de seguir nuestra Requests (peticion) que sera manejada en nuestro
controlador en la funcion store().
Como sigue:  
    return $request->input('name'); //Con esto solo vemos el atributo del input que llamamos name
    //return $request->all();//Esto para visualizar el objeto en si que se esta pasando.
14. ORM Object Relational Mapping
Es una tecnica de programacion para convertir datos utilizando un lenguaje de programacion orientado
a objetos y la utilizacion de una base de datos relacional como motor de persistencia.
Ahora bien con PHP trabajamos en Laravel con Eloquent
Eloquent proporciona una implementacio de ActiveRecord bella y sencilla para trabajar con nuestra
base de datos. Cada tabla tiene un "Modelo" correspondiente que se utiliza para interactuar con esa tabla.
Los modelos le permiten consultar datos en sus tablas, asi como insertar nuevos registros en la misma.
"Modelo": Es la representacion de la informacion. Su trabajo: gestionar dicha informacion.
15. Modelos y Migraciones
Como crear un modelo: php artisan make:model Trainer //Eloquent establece que el nombre de los modelos debe ser en singular OJO
Se puede crear el modelo y de una la migracion; como sigue:
    php artisan make:model Trainer --migration  //con este flag --migration o -m establecemos crear la migracion y el modelo de una vez.
El modelo estara en app. Y la migracion estara en database/migrations
En el archivo de la migracion nosotros podemos a traves de comando establecer que campos tendra
la tabla de nuestro modelo. 
    En la documentacion: https://laravel.com/docs/6.x/migrations
Podemos encontrar los distintos comandos que podemos usar en nuestra creacion de columnas de nuestro modelo.
Notemos que el archivo de migracion contiene una class con dos metodos uno es up() y otro down()
notablemente cada uno de ellos lo que hace es o crear la tabla o eliminarla.
Dentro del metodo up(), se ve originalmente como sigue:
public function up()
    {
        Schema::create('trainers', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
        });
    }
Nosotros para nuestro caso solo incluiremos el comando para guardar el nombre del trainer:
    $table->string('name');
Ahora debemos acomodar el controlador que se encargara de almacenar el nuevo trainer, como sigue:
    $trainer = new Trainer();
    $trainer->name = $request->input('name');
    $trainer->save();
16. MySQL
Laravel soporta los siguientes gestores de base de datos:
MySQL 5.6+ 
PostgreSQL 9.4+ 
SQLite 3.8.8+
SQL Server 2017+ 
Como llevar a cabo la configuracion: ir a config/database.php
Si vemos el archivo tiene las configuraciones necesarias para trabajar con cada gestor alli.
Si notamos entre las palabras reservada alli usadas veremos al enviroment 'env'
Este archivo .env esta en la raiz de nuestro proyecto y debe ser configurado en cada equipo que haya de ser usado
Porque? Pues porque es un archivo que esta ignorado por defecto en git y naturalmente debe ser asi
pues este archivo contiene informacion de credenciales para acceder a la base de datos.
Por ello si ejecutas el proyecto en otro equipo pues deberas configurar con antelacion el archivo .env antes de hacer cualquier prueba.
En mi caso actal, uso Wamp para levantar el servidor en mi PC asi que el archivo .env es modificado como sigue:
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=larapok_development
    DB_USERNAME=root
    DB_PASSWORD=
Una vez configurado el .env, me tome la molestia de crear manualmente la base de datos "larapok_development"
con ayuda del gesto de base de datos Workbench.
Ya una vez que tengo la base de datos creado procedo a la consola a tratar de ejecuar la migracion
    con el comando: php artisan migrate
Al ejecutar la consola me arroja este error:
    Illuminate\Database\QueryException  : SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was 
too long; max key length is 1000 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))
A que se debe esto? Pues a que Laravel agrego el soporte para almacenar emojis dentro de nuestra
base de datos, lo cual es que si usamos una version vieja de MySQL o de MariaDB.
Esto lo podemos leer en la documentacion de Laravel:
    https://laravel.com/docs/6.x/migrations#running-migrations
    En la seccion: Index Lengths & MySQL / MariaDB
Nos explican que podemos presentar este tipo de problemas y como solucionarlo.
Siguiendo el consejo descrito en al documentacion de Laravel pues debes agregar lo que sigue:
    Schema::defaultStringLength(191);
Dentro del AppServiceProvider
Este archivo se encuentra en app/Providers..
Escribimos dentro del metodo boot() tal como explica la documentacion y ademas incluir:
    use Illuminate\Support\Facades\Schema; Para poder hacer uso del Schema incluido..
Vamos de nuevo a Workbench. Ejecutamos drop database para eliminar la base de datos y de nuevo:
create database larapok_development.
Una vez hecho esto pues sencillamente ejecutamos en la consola:
php artisan migrate
Ya una vez que hemos creado correctamente las migraciones a nuestra base de datos podemos ir
    a nuestra ruta: 127.0.0.1:8000/trainers/create 
Para crear nuestro primer trainer.
OJO Debemos estar atentos a lo siguiente. Si chequeamos nuestro archivo TrainerController.php
vemos que deseamos crear un nuevo Trainer() que fue el modelo que creamos con anterioridad, pero
este modelo no ha sido incluido dentro de nuestro archivo TrainerController.php.
Para incluirlo debemos indicarselo como sigue:
    use LaraPok\Trainer;
17.CRUD (Read)
Ahora vamos a mostrar la informacion almacenada de la manera correcta:
Para ello lo primero es que dentro de nuestro controlador debemos indicar a donde debe dirigirse para buscar la vista
Para ellos en el metodo index le indicamos que ahora alli sera para retornar una vista; como sigue:
    return view('trainers.index');
Entonces debemos crear la nueva vista en resources/views/trainers
    index.blade.php
En nuestro controlador ahora en el metodo index creamos una variable que contenga a los trainers
que vamos a mostrar y para ellos pues debemos decirle que se traiga a todos los alli registrados 
y queden almacenados en dicha variable, como se hace posible? Pues asi:
    $trainers = Trainer::all();
    return view('trainers.index', compact('trainers'));
Ademas como vemos en el return debemos pasarle por parametro la funcion compact() a la que se 
le pasa por parametro la variable almacenadora que estamos usando.
    Ya en nuestro index.balde.php establecemos el card de como se veran los trainers:
    <div class="row">
            <div class="col-sm">
                <div class="card" style="width: 18rem;">
                    {{-- <img src="..." class="card-img-top" alt="..."> --}}
                    <div class="card-body">
                      <h5 class="card-title">{{$trainer->name}}</h5>
                      <p class="card-text">Some quick example text to build on the card title and make up the bulk of the card's content.</p>
                      <a href="#" class="btn btn-primary">Go somewhere</a>
                    </div>
                </div>
            </div>
        </div>
18. Subir archivos
Bien ahora vamos a ver como subimos las imagenes de los trainers a nuestra base de datos para ellos primero vamos a crear con la ayuda de artisan una nueva agregada del avatar a nuestra tabla de trainers:
    php artisan make:migration add_avatar_to_trainers_table --table=trainers
    //Aqui como vemos recibe un nombre la migracion y un flag que es a que tabla se va a agregar dicha migracion.
Una vez creada nuestra migracion pues simplemente alli (database/migrations/) vamos a agregar un campo mas a nuestra tabla de trainers y vamos simplemente a indicarle de que tipo sera este nuevo campo.
    public function up()
    {
        Schema::table('trainers', function (Blueprint $table) {
            $table->string('avatar');
        });
    }
Este campo nuevo es de tipo string puesto que no guardaremos directamente la imagen en la base de datos sino que guardaremos una referencia de la misma (No se recomienda guardar en las bases de datos la imagen en si, se guarda en cambio la referencia o Path de la misma).
Ejecutamos en la consola:
    php artisan migrate
Lo siguiente es modificar el formulario de creacion de trainers:
    <div class="form-group">
        <input type="file" name="avatar">            
        <label for="">Avatar</label>
    </div>
Ademas debemos agregar el enctype como sigue a la etiqueta <form> para que envie correctamente la informacion:
    <form class="form-group" action="/trainers" method="POST" enctype="multipart/form-data">
Ahora en la consola levantamos la aplicacion 
    php artisan serve
Ahora recordemos que quien se hace cargo de esa peticion es el controlador.
Debemos ir a nuestro controlador y al metodo store() comentamos lo que ya teniamos y agregamos temporalmente lo siguiete:
    return $request;
Esto para ver en el navegador el objeto que se esta enviando y verlo correctamente.
Una vez verificado que se envia bien el objeto modificamos como sigue:
    public function store(Request $request)
    {
        if($request->hasFile('avatar')){ //se verifica que se este pasando un archivo
            $file =$request->file('avatar');
            $name = time().$file->getClientOriginalName(); //Se le asigan un nombre unico
            $file->move(public_path().'/images/',$name) //Se guarda el archivo en nuestra carpeta public.
            //return $name;
        }
        //return $request; //cap 18 para ve que se esta enviando en el browser
        $trainer = new Trainer();
        $trainer->name = $request->input('name');
        $trainer->avatar = $name;
        $trainer->save();

        return 'Saved'; 
Ya podemos verificar con ayuda de Workbench que todo se registra correctamente.
Ahora debemos ir al index de nuestros trainer para poder agregar la imagen de cada trainer.
    



Quede en el video #19 sin iniciar aun  de la serie: https://www.youtube.com/playlist?list=PLIddmSRJEJ0sxS-RmqdRMlkyWOQWvEGEt