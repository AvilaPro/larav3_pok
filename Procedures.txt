1. Con composer: composer create-project --prefer-dist laravel/laravel "nombre"
2. Con php artisan list   Se puede ver una lista de los comandos disponibles con artisan
2.1  Escribiendo cualquiera de los comandos listados le podemos pasar el flag "-h" y con ello obtendremos mas claridad del que 
hace cada comando y que dato espera.
2.2 Como por ejemplo: php arisan make:controller -h    Este serviria para ver la ayuda de ese comando.
3. Podemos darle nombre a nuestra aplicacion a traves del comando php artisan app:name "nombre"
3.1 Si al ejecutar el comando anterior da el siguiente mensaje: "There are no commands defined in the "app" namespace" 
deberas solucionarlo con lo siguiente: composer require andrey-helldar/laravel-app --dev (y con esto ya puedes repetir 
el punto 3.)
4. Cambiar dentro de config/app.php modificar el time zone por: America/Caracas (asi en mi caso)
5. Alli mismo cambiar el idioma: 'locale' => 'es,
6. Ahora para que exista el idioma espanol dentro de nuestro proyexto debemos ir a resorces/lang/ crear una nueva 
carpeta llamado "es" alli crear cada una de los archivos encontrados en la carpeta "en" y sacando del repositorio 
(https://github.com/caouecs/Laravel-lang) entramos a src/ y alli buscamos es/ y vamos copiando la informacion en los 
archivos requeridos.
7.Recordar que HTTP es el protocolo de comunicacion que permite las transferencias de informacion en la WWW World Wide Web
La Http define una serie de metodos para poder hacer uso de los recursos disponibles, entre estos metodos esta GET. El GET solicita
una representaccion del recurso solicitado. Esta POST el cual envia los datos para que sea procesados por el recurso.
Otro metodo es el PUT / PATCH se utilizan para actualizar un recuros especifico. Tambien esta el DELETE que borra un recurso especifico.
8.ROUTES Las Rutas y su importancia.
En la carpeta "routes" tenemos una ruta llamada web.php.
Si escribimos en la consola php artisan serve nos cargara la vista en la ruta de la ip de laravel
Como podemos crear nuestras propia ruta? Pues en el archivo mecionado se copia lo siguiente:
Route:: con el verbo HTTP get y un nombre a esa ruta, dentro de los parametros del get podemos colocar uestra closure que no es mas que una funcion.
Queda asi: Route::get('/nombre_ruta', function(){
    return 'Hello World, es mi primera ruta :P';
});
Podemos ver esta nueva ruta colocandola en el navegador.
Con 127.0.0.1:8000/nombre_ruta
Tambien podemos recibir informacion como parametro dentro de nuestra ruta
Ruta con parametro: 
Route::get('/name/{name}', function($name){
    return 'Hola soy '. $name . ' '. $lastname;
});
para poder accesar correctamente a las rutas que reciben parametros debemos ingresar todos los parametros que le pensamos pasar.
Sin embargo podemos colocar valores por defecto a los parametros e indicar que dichos parametros son opcionales.
Como se hace eso? Pues escribiendo como sigue:
Route::get('/name/{name}/lastname/{lastname?}', function($name, $lastname = null){
    return 
});
Aqui el parametro name es obligatorio por lo que debe pasarse obligatoriamente y el parametro lastname no es obligatorio y por ende se le da un posible valor por defecto (en este caso null)
9. CONTROLLER Controladores
Los controladores se almacenan en la carpeta App/Http/Controllers
Alli se alamacenan los controladores
Para crear un nuevo controlador hay dos maneras: Manual y artisan
Manual: Vamos a la carpeta y manualmente creamos un archivo .php que sera nuestro controlador.
Ej: PruebaController.php
<?php

namespace LaraPok\Http\Controllers;

use LaraPok\Http\Controllers\Controller; //Por eso de la erencia se incluye esto

class PruebaController extends Controller{ //Recordar que esta clase hereda de Controller
    /* public function prueba(){
        return 'Estoy dentro de PruebController XD'; 
    Con este verificamos que entre correctamente a la funcion y al controlador*/
    public function prueba($param){
        return 'Estoy dentro de PruebController recibo este parametro '.$param;
        //esta func ya recibe parametros que se pueden pasar por el metodo get de la ruta.
    }
}
Como podemos usar este controlador?
Pues vamos a las rutas y hacemos los siguiente en el archivo web.php
//Route::get('prueba', 'PruebaController@prueba'); //paso 1 cap9
//Aqui como primer param se incluye la palabra con que accedere
//en este caso prueba, luego separado por una coma ','
//el nombre del controladora y con un '@' colocamos la funcion que debera ejecutarse
Route::get('prueba/{name}', 'PruebaController@prueba'); //paso2 cap9
//Aqui se le pasa por parametro si se desea un valor que se manejara en le controlador
10. CONTROLADORES Crear un enrutado Rest Full
Esto de REST Full se refiere a un end-point que implementa REST. REST es o se define un conjunto 
de principios arquitectónicos por los que se pueden diseñar servicios Web que se centran en 
los recursos de un sistema, lo que incluye la forma en que los estados de los recursos se 
dirigen y transfieren a través de HTTP por un amplio rango de clientes que están escritos en 
diferentes lenguajes.
Para empezar a trabajar con Rest en laravel podemos aprovechar la herramienta de 
laravel: Resource Controller
el comando es de terminal: php artisan make:controller TrainerController --resource
En nuestro caso fue ese porque es el controlador que se usara para cada "entrenador" Poke.
Este controlador se encuentra en la ruta especificada que hablamos en el punto 9.
    App/Http/Controllers
En este controlador creado con artisan ya estara completamente el CRUD creado.
Podemos crear la ruta del mismo en nuestro archivo web.php como sigue:
    Route::resource('trainers','TrainerController');
    //Con esta ruta definida sabremos que tenemos acceso a nuestro controlador. //cap 10
    //Como lo sabemos? Pues es lo que esta expuesto en la documentacion de laravel en #Resource Controller
Aqui dejo al URl actual de la documentacion: https://laravel.com/docs/6.x/controllers#resource-controllers
Tambien dentro de nuestro controlador creado en el index colocamos esto para probar que funciona:
 return 'Hola desde el controlador Trainers';
11. VIEWS Vistas
Una vista es la capa de presentacion en como mostramos informacion a un usuario.
Como deseamos tener una vista para el registro de un trainer debemos crearla y ademas
invocarla desde el controlador de trainers.
    En TrainerController en la funcion create() retornaremos la vista para crear dicho trainer.
    En la carpeta de resources/views/ crearemos una subcarpeta para todo lo que tenga que ver con
los trainer. Dentro crearemos el archivo create.blade.php y en el controlador le indicaremos que
el debera mostrar dicha vista de la siguiente forma: return view('trainers.create');
En nuestra vista (create.blade.php) creamos la estructura html que vamos a mostrar. Ademas podemos
linkear el Bootstrap CDN para que sea mas facil crear la estructura.
    Para obtener el Bootstrap CDN: https://getbootstrap.com/docs/4.4/getting-started/introduction/
    Si seguimos los pasos y las instrucciones alli dadas nos daremos cuenta que debemos incluir
    un <link> con  la inclusion de Bootstrap y unos scripts que incluiran JS, tal como lo indica la nota Bootstrap:
    "Muchos de nuestros componentes requieren el uso de JavaScript para funcionar. Específicamente, requieren jQuery , Popper.js y nuestros propios complementos de JavaScript. Coloque los siguientes <script>mensajes de correo cerca del final de sus páginas, justo antes de la </body>etiqueta de cierre , para habilitarlos. jQuery debe venir primero, luego Popper.js, y luego nuestros complementos de JavaScript."
12. BLADE
Blade es una herramienta que implementa laravel para crear plantillas dentro sus aplicaciones.
Para trabajar con Blade basta con conocer sus directivas.
Primero se recomienda crear una carpeta dentro de views llamada layouts/
Alli podemos crear nuestras clases padres de plantillas blade
    Para establecer directivas de clase padre se usa la directiva @yield('nombre') 
    Para que una plantilla pueda ser usada en otra vista se usa la directiva @extends('layouts.nameLayout')
    Para introducir contenido html a la directiva padre se usa la directiva @section('nameLayout')
Dentro se escribe el html a ser usado
Se cierra con un @endsection
Nota: no todas las directivas @section ameritan ser abiertas y cerradas, solo se cierran aquellas que contengan estructura html
13. HTTP Requests
Los Requests es el servicio de poder ejecutar en si en CRUD.
Para nuestro ejemplo vamos a crear el nuevo Trainer. Para ello debemos englobar lo que hemos creado en la vista create dentro de un form.
Como sigue: 
    <form class="form-group" action="/trainers" method="POST">
La clase es la de Bootstrap, el metodo es POST y el action tal como se ve en la documentacion 
de laravel es la ruta que ah de seguir nuestra Requests (peticion) que sera manejada en nuestro
controlador en la funcion store().
Como sigue:  
    return $request->input('name'); //Con esto solo vemos el atributo del input que llamamos name
    //return $request->all();//Esto para visualizar el objeto en si que se esta pasando.
14. ORM Object Relational Mapping
Es una tecnica de programacion para convertir datos utilizando un lenguaje de programacion orientado
a objetos y la utilizacion de una base de datos relacional como motor de persistencia.
Ahora bien con PHP trabajamos en Laravel con Eloquent
Eloquent proporciona una implementacio de ActiveRecord bella y sencilla para trabajar con nuestra
base de datos. Cada tabla tiene un "Modelo" correspondiente que se utiliza para interactuar con esa tabla.
Los modelos le permiten consultar datos en sus tablas, asi como insertar nuevos registros en la misma.
"Modelo": Es la representacion de la informacion. Su trabajo: gestionar dicha informacion.
15. Modelos y Migraciones
Como crear un modelo: php artisan make:model Trainer //Eloquent establece que el nombre de los modelos debe ser en singular OJO
Se puede crear el modelo y de una la migracion; como sigue:
    php artisan make:model Trainer --migration  //con este flag --migration o -m establecemos crear la migracion y el modelo de una vez.
El modelo estara en app. Y la migracion estara en database/migrations
En el archivo de la migracion nosotros podemos a traves de comando establecer que campos tendra
la tabla de nuestro modelo. 
    En la documentacion: https://laravel.com/docs/6.x/migrations
Podemos encontrar los distintos comandos que podemos usar en nuestra creacion de columnas de nuestro modelo.
Notemos que el archivo de migracion contiene una class con dos metodos uno es up() y otro down()
notablemente cada uno de ellos lo que hace es o crear la tabla o eliminarla.
Dentro del metodo up(), se ve originalmente como sigue:
public function up()
    {
        Schema::create('trainers', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
        });
    }
Nosotros para nuestro caso solo incluiremos el comando para guardar el nombre del trainer:
    $table->string('name');
Ahora debemos acomodar el controlador que se encargara de almacenar el nuevo trainer, como sigue:
    $trainer = new Trainer();
    $trainer->name = $request->input('name');
    $trainer->save();
16. MySQL
Laravel soporta los siguientes gestores de base de datos:
MySQL 5.6+ 
PostgreSQL 9.4+ 
SQLite 3.8.8+
SQL Server 2017+ 
Como llevar a cabo la configuracion: ir a config/database.php
Si vemos el archivo tiene las configuraciones necesarias para trabajar con cada gestor alli.
Si notamos entre las palabras reservada alli usadas veremos al enviroment 'env'
Este archivo .env esta en la raiz de nuestro proyecto y debe ser configurado en cada equipo que haya de ser usado
Porque? Pues porque es un archivo que esta ignorado por defecto en git y naturalmente debe ser asi
pues este archivo contiene informacion de credenciales para acceder a la base de datos.
Por ello si ejecutas el proyecto en otro equipo pues deberas configurar con antelacion el archivo .env antes de hacer cualquier prueba.
En mi caso actal, uso Wamp para levantar el servidor en mi PC asi que el archivo .env es modificado como sigue:
    DB_CONNECTION=mysql
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_DATABASE=larapok_development
    DB_USERNAME=root
    DB_PASSWORD=
Una vez configurado el .env, me tome la molestia de crear manualmente la base de datos "larapok_development"
con ayuda del gesto de base de datos Workbench.
Ya una vez que tengo la base de datos creado procedo a la consola a tratar de ejecuar la migracion
    con el comando: php artisan migrate
Al ejecutar la consola me arroja este error:
    Illuminate\Database\QueryException  : SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was 
too long; max key length is 1000 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))
A que se debe esto? Pues a que Laravel agrego el soporte para almacenar emojis dentro de nuestra
base de datos, lo cual es que si usamos una version vieja de MySQL o de MariaDB.
Esto lo podemos leer en la documentacion de Laravel:
    https://laravel.com/docs/6.x/migrations#running-migrations
    En la seccion: Index Lengths & MySQL / MariaDB
Nos explican que podemos presentar este tipo de problemas y como solucionarlo.
Siguiendo el consejo descrito en al documentacion de Laravel pues debes agregar lo que sigue:
    Schema::defaultStringLength(191);
Dentro del AppServiceProvider
Este archivo se encuentra en app/Providers..
Escribimos dentro del metodo boot() tal como explica la documentacion y ademas incluir:
    use Illuminate\Support\Facades\Schema; Para poder hacer uso del Schema incluido..
Vamos de nuevo a Workbench. Ejecutamos drop database para eliminar la base de datos y de nuevo:
create database larapok_development.
Una vez hecho esto pues sencillamente ejecutamos en la consola:
    php artisan migrate
Ya una vez que hemos creado correctamente las migraciones a nuestra base de datos podemos ir
    a nuestra ruta: 127.0.0.1:8000/trainers/create 
Para crear nuestro primer trainer.
OJO Debemos estar atentos a lo siguiente. Si chequeamos nuestro archivo TrainerController.php
vemos que deseamos crear un nuevo Trainer() que fue el modelo que creamos con anterioridad, pero
este modelo no ha sido incluido dentro de nuestro archivo TrainerController.php.
Para incluirlo debemos indicarselo como sigue:
    use LaraPok\Trainer;
17.CRUD (Read)
Ahora vamos a mostrar la informacion almacenada de la manera correcta:
Para ello lo primero es que dentro de nuestro controlador debemos indicar a donde debe dirigirse para buscar la vista
Para ellos en el metodo index le indicamos que ahora alli sera para retornar una vista; como sigue:
    return view('trainers.index');
Entonces debemos crear la nueva vista en resources/views/trainers
    index.blade.php
En nuestro controlador ahora en el metodo index creamos una variable que contenga a los trainers
que vamos a mostrar y para ellos pues debemos decirle que se traiga a todos los alli registrados 
y queden almacenados en dicha variable, como se hace posible? Pues asi:
    $trainers = Trainer::all();
    return view('trainers.index', compact('trainers'));
Ademas como vemos en el return debemos pasarle por parametro la funcion compact() a la que se 
le pasa por parametro la variable almacenadora que estamos usando.
    Ya en nuestro index.balde.php establecemos el card de como se veran los trainers:
    <div class="row">
            <div class="col-sm">
                <div class="card" style="width: 18rem;">
                    {{-- <img src="..." class="card-img-top" alt="..."> --}}
                    <div class="card-body">
                      <h5 class="card-title">{{$trainer->name}}</h5>
                      <p class="card-text">Some quick example text to build on the card title and make up the bulk of the card's content.</p>
                      <a href="#" class="btn btn-primary">Go somewhere</a>
                    </div>
                </div>
            </div>
        </div>
18. Subir archivos
Bien ahora vamos a ver como subimos las imagenes de los trainers a nuestra base de datos para ellos primero vamos a crear con la ayuda de artisan una nueva agregada del avatar a nuestra tabla de trainers:
    php artisan make:migration add_avatar_to_trainers_table --table=trainers
    //Aqui como vemos recibe un nombre la migracion y un flag que es a que tabla se va a agregar dicha migracion.
Una vez creada nuestra migracion pues simplemente alli (database/migrations/) vamos a agregar un campo mas a nuestra tabla de trainers y vamos simplemente a indicarle de que tipo sera este nuevo campo.
    public function up()
    {
        Schema::table('trainers', function (Blueprint $table) {
            $table->string('avatar');
        });
    }
Este campo nuevo es de tipo string puesto que no guardaremos directamente la imagen en la base de datos sino que guardaremos una referencia de la misma (No se recomienda guardar en las bases de datos la imagen en si, se guarda en cambio la referencia o Path de la misma).
Ejecutamos en la consola:
    php artisan migrate
Lo siguiente es modificar el formulario de creacion de trainers:
    <div class="form-group">
        <input type="file" name="avatar">            
        <label for="">Avatar</label>
    </div>
Ademas debemos agregar el enctype como sigue a la etiqueta <form> para que envie correctamente la informacion:
    <form class="form-group" action="/trainers" method="POST" enctype="multipart/form-data">
Ahora en la consola levantamos la aplicacion 
    php artisan serve
Ahora recordemos que quien se hace cargo de esa peticion es el controlador.
Debemos ir a nuestro controlador y al metodo store() comentamos lo que ya teniamos y agregamos temporalmente lo siguiete:
    return $request;
Esto para ver en el navegador el objeto que se esta enviando y verlo correctamente.
Una vez verificado que se envia bien el objeto modificamos como sigue:
    public function store(Request $request)
    {
        if($request->hasFile('avatar')){ //se verifica que se este pasando un archivo
            $file =$request->file('avatar');
            $name = time().$file->getClientOriginalName(); //Se le asigan un nombre unico
            $file->move(public_path().'/images/',$name) //Se guarda el archivo en nuestra carpeta public.
            //return $name;
        }
        //return $request; //cap 18 para ve que se esta enviando en el browser
        $trainer = new Trainer();
        $trainer->name = $request->input('name');
        $trainer->avatar = $name;
        $trainer->save();

        return 'Saved'; 
Ya podemos verificar con ayuda de Workbench que todo se registra correctamente.
Ahora debemos ir al index de nuestros trainer para poder agregar la imagen de cada trainer.
19. Vista Trainers
Buenos aqui solo se llevaron a vabo cambios en la forma en que se iban a presentar los trainer ejecutando cambios directamente en el codigo de la vista, que en nuestro caso corresponde al index.blade.php de trainers
Se ejecuto como sigue:
    @section('content')
    <div class="row">
        @foreach ($trainers as $trainer)
            <div class="col-sm">
                <div class="card text-center" style="width: 18rem; margin-top: 70px">
                <img style="height: 150px; width:150px; backgroud-color: #EFEFEF; margin:20px" src="images/{{$trainer->avatar}}" alt="" class="card-img-top rounded-circle mx-auto d-block">
                    <div class="card-body">
                      <h5 class="card-title">{{$trainer->name}}</h5>
                      <p class="card-text">{{$trainer->description}}</p>
                      <a href="#" class="btn btn-primary">Conocer Mas</a>
                    </div>
                </div>
            </div>
        @endforeach
    </div>
20. Show de los trainers
Ahora queremos mostrar mas detalle de los trainers
Bien, tal como lo describe la documentacion de laravel en su seccion de controllers:
    https://laravel.com/docs/6.x/controllers#resource-controllers
Actions Handled By Resource Controller
Verb	    URI	                    Action	    Route Name
GET	        /photos	                index	    photos.index
GET	        /photos/create	        create	    photos.create
POST	    /photos	                store	    photos.store
GET	        /photos/{photo} 	    show	    photos.show
GET	        /photos/{photo}/edit    edit	    photos.edit
PUT/PATCH	/photos/{photo}	        update  	photos.update
DELETE	    /photos/{photo}	        destroy	    photos.destroy

Tal como podemos ver en la tabla podemos valernos del metodo GET para accionar con Show una muestra de detalles del trainer a traves del boton que a este le hemos incluido.
Como sigue:
    <a href="/trainers/{{$trainer->id}}" class="btn btn-primary">Conocer Mas</a>
Ahora vamos al controlador.
En el metodo show() le decimos que debemos devolver la vista como sigue:
    public function show($id)
    {
        return view('trainers.show');
        //return 'tengo que retornar el recurso con el id '.$id;
    }
Creamos el nuevo archivo en las views/trainers:
    show.blade.php
Alli cargamos como se vera dicha vista:
    @extends('layouts.app')

    @section('title', 'Trainer')

    @section('content')
    <img style="height: 200px; width:200px; backgroud-color: #EFEFEF; margin:20px" src="/images/{{$trainer->avatar}}" alt="" class="card-img-top rounded-circle mx-auto d-block">
    <div class="text-center">
    <h5 class="card-title">{{$trainer->name}}</h5>
        <p>{{$trainer->description}} </p>
    </div>
    @endsection
Ahora veremos un poco del Implicit Binding
Este lo que hace es resolver de manera automaticamente los modelos definidos en Eloquent.
Como se puede ver en la documentacion de laravel:
    https://laravel.com/docs/6.x/routing#implicit-binding
Se ve que hay una ruta, un parametro $user y dentro del closure hay un modelo de tipo $user y como estas variables coinciden entonces Eloquent se encarga de cargar el modelo de manera automatica.
Asi ayudandonos con esto podemos editar el metodo show() del controlador, como sigue:
    public function show(Trainer $trainer) //Definido el Implicit Binding en el controlador
    {
        //$trainer = Trainer::find($id);
        //return $trainer;
        return view('trainers.show', compact('trainer'));
        //return 'tengo que retornar el recurso con el id '.$id;
    }
21. Slugs
Es una forma amigable de representar el texto de nuestros enlaces.
La funcionalidad principal que se desea tener con un slug es no mostrar variables en el URL del enlace.
PORQUE? Pues sencillamente no queremos que nuestros usuarios finales puedan inferir de que forma se usan las variables en nuestra aplicacion.
Creamos otro columna a la tabla de los trainers llamada slug que sera la clave con la que de ahora en adelante accederemos a los datos.
En consola ejecutamos:
    php artisan make:migration add_slug_to_trainers --table=trainers
Vamos al archivo creado que ahora se encontrara en database/migrations y modificamos como sigue:
    public function up()
    {
        Schema::table('trainers', function (Blueprint $table) {
            $table->string('slug')->unique();
        });
    }
    public function down()
    {
        Schema::table('trainers', function (Blueprint $table) {
            $table->dropColumn('slug');
        });
    }
Ambas funciones una para crear y otra para poder eliminar.
Tambien debemos cambiar el metodo show() de nuestro controlador:
    public function show($slug) //Definido el Implicit Binding en el controlador
    {
        $trainer = Trainer::where('slug','=',$slug)->firstOrFail();
        //$trainer = Trainer::find($id);
        //return $trainer;
        return view('trainers.show', compact('trainer'));
        //return 'tengo que retornar el recurso con el id '.$id;
    }
Ya no a traves del binding (con el uso del $id) sino a traves del slug.
22. Custom Implicit Binding
Como vimos en el capitulo anterior implicit binding lo quitamos porque estaba previamente configurado para abrir con el $id y nos interesaba es conectar a traves del slug.
Pues podemos customizar (modificar) el implicit binding tal como lo muestra la documentacion:
    https://laravel.com/docs/6.x/routing#implicit-binding
Tan solo copiamos lo que nos indica la documentacion y vamos a pegarlo en la ruta de nuestro modelo Trainer.php
    /**
     * Get the route key for the model.
     *
     * @return string
     */
    public function getRouteKeyName()
    {
        return 'slug';
    }
Volvemos a modificar nuestro show() en el controlador:
    public function show(Trainer $trainer) //Definido el Implicit Binding en el controlador
    {
        return view('trainers.show', compact('trainer'));
    }
Ahora lo dejamos simplemente asi.
23. Actualizar Trainer (CRUD Update)
Bien ahora debemos activar un boton que nos permita editar, actualizar o updatear nuestros trainer.
Para ello podemos hacerlo en la vista de show, agregando un boton y cambiando la ruta del mismo:
    <a href="/trainers/{{$trainer->slug}}/edit" class="btn btn-primary">Editar trainer</a>
Cambiamos en nuestro controlador el metodo edit():
    public function edit(Trainer $trainer)
    {
        return view('trainers.edit', compact('trainer'));
    }
Y creamos en resources/views/trainers el archivo:
    edit.blade.php
Lo editamos:
    @extends('layouts.app')
    @section('title', 'Trainer Edit')
    @section('content')
    <form class="form-group" action="/trainers" method="POST" enctype="multipart/form-data">
        @csrf
        <div class="form-group">
            <label for="">Nombre</label>
        <input type="text" name="name" class="form-control" value="{{$trainer->name}}">
        </div>

        <div class="form-group">
            <label for="">Descripcion</label>
             <input type="text" name="description" class="form-control" value="{{$trainer->description}}">
        </div>

        <div class="form-group">
            <label for="">Avatar Actual</label>
            <img style="height: 200px; width:200px; backgroud-color: #EFEFEF; margin:20px" src="/images/{{$trainer->avatar}}" alt="" class="card-img-top rounded-circle mx-auto d-block">
            <label for="">Modificar Avatar:</label>
            <input type="file" name="avatar">
        </div>
 
        <button type="submit" class="btn btn-primary">Actualizar</button>

    </form>
    @endsection
Ahora Bien, los formularios en html no nos soportan los metodos PUT ni PATCH ni DELETE para hacer la subida de los cambios de edicion, por lo que debemos hacerlo de forma oculta.
Lo podemos ocultar de una forma bien sencilla con la ayuda de Blade:
    @method('PUT)
Tambien debemos cambiar la ruta del action del form como sigue:
    <form class="form-group" action="/trainers/{{$trainer->slug}}" method="POST" enctype="multipart/form-data">
Ahora actualizamos nuestro metodo update() de controlador:
    public function update(Request $request, Trainer $trainer)
    {
                            //agregados cap 23
        //return $trainer; //agregado para ver que si estaba llegando el trainer actualizado
        //return $request; //con esto verificamos que correctamente este ejecutando el metodo PUT.
        
        $trainer->fill($request->except('avatar'));
        if($request->hasFile('avatar')){ //se verifica que se este pasando un archivo
            $file =$request->file('avatar');
            $name = time().$file->getClientOriginalName(); //Se le asigan un nombre unico
            $trainer->avatar = $name;
            $file->move(public_path().'/images/',$name); //Se guarda el archivo en nuestra carpeta public.
        }
        $trainer->save();
        return 'actualizado';
    }
Y tambien debemos indicarle a nuestro modelo que campos se pueden actualizar, debemos ir a nuestro archivo del modelo Trainer.php
    protected $fillable = ['name', 'description', 'avatar'];
24. Laravel Collective
Laravel Collective es un complemento que permite generar formularios y etiquetas html con un toque mas profesional al usar laravel.
Veremos como utilizar Laravel Collective.
Si vemos tal como vemos en la documentacion:
    https://laravelcollective.com/docs/6.0/html
Tal como se puede ver en la documentacion creamos la clave de Laravel Collective:
    {!!  Form::open(['route' => 'trainers.store', 'method' => 'POST', 'files' => true]) !!}
Se cierra esta estructura como sigue:
    {!! Form::close() !!}
Dentro de estas sentencias vamos a crear las sentecias que van dentro del form como las establece laravel collective.
    {!!  Form::open(['route' => 'trainers.store', 'method' => 'POST', 'files' => true]) !!}
        {!! Form::token() !!} //Esto para el csrf.
        <div class="form-group">
            {!! Form::label('name', 'Nombre') !!}
            {!! Form::text('name', null, ['class' => 'form-control']) !!}
        </div>
        <div class="form-group">
            {!! Form::label('description', 'Description') !!}
            {!! Form::text('description', null, ['class' => 'form-control']) !!}
        </div>
        <div class="form-group">
            {!! Form::label('avatar', 'Avatar') !!}
            {!! Form::file('avatar') !!}
        </div>

        {!! Form::submit('Guardar', ['class' => 'btn btn-primary']) !!}
    {!! Form::close() !!}
OJO. Recordar que en nuestra tabla de trainers decidimos agregar un slug. Asi que para que este se agregue al momento de crear al nuevo trainer debemos determnar de que forma se va a agregar a la base de datos. Para ello debemos ir a nuestro controlador en nuestro metodo store y determinar de que forma se va a crear ese slug. Para ejemplo yo agregue lo que sigue:
    $trainer->slug = $TR.$request->input('name');
25. Sub views
Ahora trabajaremos en pro de eliminar en nuestros trabajos el D.R.Y que no es mas que "Dont Repeat Yourself" que traducido no es mas que "No Te Repitas" y es el cuidado que debemos tener en no repetir codigo en nuestras plantillas o vistas.
Para empezar vamos a:
    resorces/views/trainers
y creamos alli una nueva vista.
la hemos llamado en nuestro proyecto:
    form.blade.php
alli hemos cortado de la vista "create" en esta nueva vista "form" que hemos creado lo siguiente:
    <div class="form-group">
        {!! Form::label('name', 'Nombre') !!}
        {!! Form::text('name', null, ['class' => 'form-control']) !!}
    </div>
    <div class="form-group">
        {!! Form::label('description', 'Description') !!}
        {!! Form::text('description', null, ['class' => 'form-control']) !!}
    </div>
    <div class="form-group">
        {!! Form::label('avatar', 'Avatar') !!}
        {!! Form::file('avatar') !!}
    </div>
y dentro de la vista "create" hemos incluido la directriz que nos explica en la documentacion de laravel:
    https://laravel.com/docs/6.x/blade#including-subviews
La directriz es:
    @include('trainers.form')
Haremos lo mismo en la vista "edit"
26. Validaciones
Vamos a hacer uso de lo indicado en la documentacion de laravel para este caso
    https://laravel.com/docs/6.x/validation#available-validation-rules
para ello vamos a nuestra funcion 'store' y alli establecemos como ha de ser la validacion.
Primero vamos a crear una variable que llamaremos como datos validados ($validateData) y para que ella funcione vamos a asignarle el request con la funcion validate() y validate recibe un  array con las condiciones de cada campo que tendra que validar.
Asi que en TrainerController en el metodo store() escribiremos como sigue:
    $validateData = $request->validate([
        'name' => 'required|max: 10',
        'description' => 'required|max: 128',
        'avatar' => 'required|image'
    ]);
Cuando las condiciones de nuestras Validaciones no son validas nuestra funcion validate() suele devolvernos a la vista en donde estabamos, y en el caso de que estemos haciendo peticiones AJAX el nos devolveria un Json 
Ahora para poder mostrarle a nuestros usuarios que no esta validados laravel nos ofrece una variable llamada 'errors' y ella es la que contiene los posibles errores. Ahora solo falta mostrarlas.
Vamos a nuestra vista 'create'
     @if ($errors->any())
        <div class="alert alert-danger">
            <ul>
                @foreach ($errors->all() as $error)
                    <li>{{ $error }}</li>
                @endforeach
            </ul>
        </div>
    @endif
27. FormRequest
Para crear nuestro Requests en la consola escribimos:
    php artisan make:request StoreTrainerRequest
Ya en la ruta 
    app/Http/Controllers/Requests
alli se creara un archivo nuevo llamado:
    StoreTrainerRequest.php
Alli hay dos funciones; authorize() este es un metodo opcional donde nosotros vamos a colocar la logica para autorizacion, pero en este caso la logica se puede manejar de forma externa, asi que le diremos a esta funcion le diremos que retorne 'true'.
Tambien alli hay otra funcion llamada rules() esta funcion lo que hace es devolvernos un array con las reglas a ser usadas para validar para nuestro caso como sigue:
    public function rules()
    {
        return [
            'name' => 'required|max: 10',
            'description' => 'required|max: 128',
            'avatar' => 'required|image'
        ];
    }
Ahora debemos decirle a nuestro controlador que usaremos dichas validaciones; para ello incluimos en el cabezal del controlador como sigue:
    use LaraPok\Http\Requests\StoreTrainerRequest;
Ademas en los parametros de la funcion store() ya no usaremos Requests sino en cambio el que acabamos de crear:
    public function store(StoreTrainerRequest $request)
28. DELETE Eliminar Trainer
Ahora veremos como eliminar un trainer
Haremos un cambio a la vista 'show' donde agregaremos un boton para que permita ejecutar dicha accion.
    {!! Form::open([ 'route' => ['trainers.destroy', $trainer->slug}], 'method' => 'DELETE']) !!}
        {!! Form::submit('Eliminar', ['class' => 'btn btn-danger']) !!}
    {!! Form::close() !!}
Ahora vamos a nuestro controlador y en la funcion destroy() debemos configurar dicha accion.
    public function destroy(Trainer $trainer)
    {
        $file_path = public_path().'/images/'.$trainer->avatar;
        
        if (@getimagesize($file_path)) {
            unlink($file_path);
        }
        else
        {
            echo "El archivo que buscas no existe";
        }
        
        $trainer->delete();
        return 'eliminado exitoso';
        //return $trainer;
        //return $file_path;
    }
Con esta linea de codigo:
    $file_path = public_path().'/images/'.$trainer->avatar;
Se obtiene la direccion local de donde esta alojado la imagen del avatar.
Con la sentencia "if" se verifica que ciertamente la imagen exista y si es asi, se elimina la misma imagen con el comando de php "unlink"
Luego con la variable $trainer y el metodo delete() eliminamos los datos del trainer ques estan en la base de datos.
    $trainer->delete();
29. HTTP Responses (Respuestas HTTP)
Ahora vamos a manejar las respuestas HTTP en laravel.
Segun la documentacion podemos manejar respuestas como "redirecciones" y tambien podemos responder con:
     "views" (vistas) 
     "Json" (archivos Json) 
     "File Downloads" (descarga de archivos) 
     "File Responses" (Respuesta de Archivo)
Bueno, por ejemplo para el momento de crear un nuevo trainer, una vez que lo hayamos creado queremos devolver la vista principal de los trainers, pues para ello usaremos lo siguiente al final del metodo "store":
    return redirect()->route('trainers.index');
Donde la sentencia que esta dentro de route es la ruta que dirige a esa vista que podemos verificar en la consola con el comando:
    php artisan route:list
Ahora para la devolucion de la vista luego de editar "update", usaremos lo siguiente:
    return redirect()->route('trainers.show', [$trainer]);
Es escrita de esta forma, vemos que dentro de "route" escribimos la ruta y ademas como parametro le pasamos un array con las variables que el pueda necesitar para acceder correctamente, recordemos que la vista "show" requiere de un parametro en especifico para poder accesar correctamente al trainer que deseamos.
30.Session Data
Para mejorar la UX (User Experience) de nuestra aplicacion vamos a notificarle a nuestro usuario cada vez que el realice una accion podamos informarle correctamente que se esta haciendo lo que el desea.
Para ello vamos al controlador Trainer y como ejemplo vamos a modificar el metodo "update":
Con el metodo with():
    with('status', 'Trainer actualizado')
y queda como sigue nuestro return
    return redirect()->route('trainers.show', [$trainer])->with('status', 'Trainer actualizado');
Ahora vamos a nuestra vista:
    show.blade.php
y verificamos que se esta comunicando correctamente la variable session que estamos pasando por parametro al metodo with.
Alli agregamos con la ayuda de blade lo siguiente para verificar que la variable se esta pasando correctamente:
    @if(session('status'))
        <div class="alert alert-success" role="alert">
            {{ session('status') }}
        </div>
    @endif
Y hacemos lo mismo para el metodo "store" y delete" que retornan ambos a la vista "index", a la cual le incluimos sus istrucciones de blade.
31. Refactor
Para ser mas reusable todo nuestro codigo todas las confirmaciones y mensajes que se generan en nustras vistas las vamos a almacenar en otros archivos y luego con sentencia de blade las incluiremos en las vistas donde las requerimos.
Para ello creamos una carpeta en "views" llamada "common" y alli podemos crear cada archivo de tipo balde donde vamos a almacenar todas esas sentencias de confirmacion que requeramos.
Por ejemplo la sentencia de errores en la vista "create" se guardo en un archivo:
    errors.blade.php
Y alli se pego dicha sentencia. 
Luego se incluyo la siguiente sentencia dentro de la vista "create"
    @include('common.errors')
Lo mismo se hizo con las notificaciones de success que se estaban mostrando en las otras vistas.
32. Autenticacion
Una caracteristica principal es la Autenticacion.
Laravel lo implementa tambien dentro del framework.
Esto tomado de la documentacion:
    El paquete de Laravel proporciona una forma rápida de andamiaje de todas las rutas y vistas que necesita para la autenticación con unos simples comandos:laravel/ui

    composer require laravel/ui "^1.0" --dev

    php artisan ui vue --auth

    Este comando debe usarse en aplicaciones nuevas e instalará una vista de diseño, vistas de registro e inicio de sesión, así como rutas para todos los puntos finales de autenticación. A HomeControllertambién se generará para manejar las solicitudes posteriores al inicio de sesión en el tablero de su aplicación.

Al ejecutar estos comandos en la consola nos aparecera un mensaje similar a este:
    The [layouts/app.blade.php] view already exists. Do you wnat to replace it? (yes/no) [no]:
Esto no es mas que el va a reemplazar el archivo app.blade.php que habiamos creado y lo va a reemplazar por el que va a crear para agregar autenticacion.

ESTO NOS VA A ELIMINAR NUESTRA BARRA NAV QUE YA TENIAMOS Y ADEMAS EL LINK QUE TENIAMOS DE Bootstrap PARA NUESTRAS VISTAS. PERO NO PREOCUPEMOS QUE LUEGO LO SOLUCIONAMOS.

Una vez ejecutados los comandos nos saldra un mensaje como sigue:
    Authentication scaffolding generated successfully.
Eso quiere decir que ya genero el archivo y todo lo necesario para el login y el register de nuestra autenticacion.
33 - 34 Roles de Usuario - Models & migrations
Vamos a crear los roles y para ello en la consola vamos a crear los modelos correspondientes
    php artisan make:model Role -m
Con el parametro -m recordamos que creamos de una vez el modelo y la migracion junto con el.
El nombre del modelo en singular y en ingles es lo mas conveniente.
Luego vamos a:
    database/migrations/... el que sea el de los roles recien creado.
Lo roles estan basados segun sea la necesidad del sitio.
Aqui se modifico como sigue:
    public function up()
    {
        Schema::create('roles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->string('description');
            $table->timestamps();
        });
    }
En nuestro caso, haremos relaciones "muchos a muchos" para ello necesitaremos una tabla pivote que maneje dichas relaciones, que guardara el id del usuario como el id del rol que desempeña. Para esto generamos esta tabla dinamica:
    php artisan make:migration create_role_user_table
Se maneja por convenciion que se ordenenen los nombres de las tablas involucradas por orden alfabetico. Por ello como las tabals involucradas son "role" y "user" se coloco en orden alfabetico al crear su migracion.
En esta tabla se modifico como sigue:
    public function up()
    {
        Schema::create('role_user', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->integer('user_id')->unsigned();
            $table-> integer('role_id')->unsigned();
            $table->timestamps();
        });
    }
Una vez hecho esto podemos ejecutar:
    php artisan migrate
Si se presentan errores aqui, como estamos en la etapa de desarrollo podemos eliminar por completo la base de datos y volverla a crear manualmente, esto nos eliminara todos los datos que hasta el momento llevabamos pero no hay de que preocuparse, puesto que estamos en "development state" y no estamos afectand seriamente algo que ya estuviese en produccion. Por ello la planificacion previa de la aplicacion se debe hacer con mucho detalle para no enfrentar errores que no se puedan solucionar facilmente luego.
Una vez hechas las migraciones debemos relacionar los Modelos. Vamos a 
    app/User.php
Alli vamos a describir un metodo que defina la relacion, para ello vamos a definir una funcion como sigue:
    public function roles(){
        return $this->belongsToMany('App\Role')
    }
Y enseguida hacemos lo mismo en el modelo de Role
    public function users(){
        return $this->belongsToMany('App\User')
    }
Ya ahora se le pueden dar roles a los usuarios utilizando seeders que es lo que desscribiremos en el siguiente capitulo.
35. Seeders
Ahora trabajaremos con Seeders. Que es un Seeder? Es basicamente un modulo que nos va a permitir almacenar datos de prueba dentro de la app. Para mas info ir a la documentacion:
    https://laravel.com/docs/6.x/seeding#introduction
Vamos a la terminal y creamos nuestros seeder. Uno de ellos para almacenar los roles y otro para almacenar nuestros usuarios.
    php artisan make:seeder RoleTableSeeder
y 
    php artisan make:seeder UserTableSeeder
Procedemos a crear nuestro seeder de roles, estos seeder estan almacenados en database/seeds
Alli empezamos a trabajar. Para el seed de Roles empezamos indicandole que vamos a trabajar con el modelo Role. Para ello lo agragamos con al ayuda del "use".
    use LaraPok\Role;
Una vez incluido, empezamos a crear el rol.
En la funcion "run" empezamos a crear el rol. Creamos un rol "admin" y uno "user"
    public function run()
    {
        $role = new Role();
        $role->name = "admin";
        $role->description = "Administrador";
        $role->save();

        $role = new Role();
        $role->name = "user";
        $role->description = "User";
        $role->save();
    }
Ahora vamos al rol de user, anexamos los modelos Role y User:
    use LaraPok\Role;
    use LaraPok\User;
Y alli en la funcion "run" preparamos para hacer el rol:
    //query para obtener la informacion que cumpla con los datos.
         
    $role_user = Role::where('name','user')->first();
    $role_admin = Role::where('name','admin')->first();
    //Hasta aqui obtenemos los dos roles y ahra solo basta asignarselo a nuestro usuario
        
    //Creamos los usuarios.
    //Les asignamos sus correspondientes atributos.
    $user = new User();
    $user->name = "User";
    $user->email = "user@gmail.com";
    $user->password = bcrypt('query');
    $user->save();

    $user->roles()->attach($role_user);

Hasta el momento tenemos roles, uno user y otro admin
Pero hasta el momento no hemos constituido ninguna relacion entre el rol y el user. Como tenemos una relacion muchos a muchos.
Con la ayuda de Eloquent (El ORM de Laravel) vamos a establecer las relaciones.
Ahora podemos decirle a laravel que mediante un user acceda a su metodo roles. Con la ayuda del metodo attach(), se establece la relacion entre User y Role.
EN este caso como no queremos perder tiempo en hacer el modulo de la creacion de usuarios. Para nuestro caso usaremos los Seeders.
Ahora solo nos falta configurar nuestra clase "DatabaseSeeder", este sera el encargado de arrancar de manera ordenada cada seeders que tenemos en nuestra app.
Alli en nuestra metodo "run"
    public function run()
    {
        $this->call(RoleTableSeeder::class);
        $this->call(UserTableSeeder::class);
    }
ANTES DE IR A CONSOLA:
Debemos ir a nuestro modelo User.php y el modelo Role.php; y en la function acomodar el modelo que estamos usando, que en nuestro caso en LaraPok. Que es el que establecimos como namespace.
    -----ASI ESTABA ANTES-----
    public function roles(){
        return $this->belongsToMany('App\Role')
    }
    -----ASI DEBE QUEDAR----
    public function roles(){
        return $this->belongsToMany('LaraPok\Role')
    }
Ahora vamos a la consola:
    php artisan migrate:refresh --seed
36. Roles de los Users - Logica de validacion
Vamos a continuar con la logica para validar cada rol dentro de nuestro usuario.
Vamos a usar nuestro modelo User, alli vamos a escribir la logica necesaria para validar los roles.
Dicha funcion para validar que nuestros usuarios tengan asignado un rol.
    public function hasRole($role){
        if($this->roles()->where('name',$role->first())){
            return true;
        }
        return false;
    }
Esta otra funcion nos permite recorrer los posibles roles que tengan nuestros usuarios. Esta funcion invoca a la funcion creada anteriormente.
    public function roles(){
        return $this->belongsToMany('LaraPok\Role');
    }

    public function hasAnyRole($roles){
        if(is_array(($roles))){
            foreach ($roles as $role){
                if($this->hasRole($role)){
                    return true;
                }
            }
        }else{
            if($this->hasRole($roles)){
                return true;
            }
        }
        return false;
    }
Ahora nos hace falta una capa que llame a esta funcion que acabamos de crear y que sea capaz de reaccionar al usuario en caso de que el mismo no este relacionado cn ningun rol.
Para ello esta en la documentacion de laravel el metodo "abort" que se encargaa de dar una respuesta a nuestro usuario en caso de que este no tenga una relacion con algun rol.
    https://laravel.com/docs/6.x/helpers#method-abort
Aqui dejo como es la funcion que debe escribirse para que se verifique la autorizacion del rol del usuario:
    public function authorizeRoles($roles){
        if($this->hasAnyRole($roles)){
            return true;
        }
        abort(401, 'This action unauthorized');
    }
37.Roles de Usuarios - Implementacion
Ahora vamos a filtrar que solo a un administrador pueda ver los trainers.
Nos vamos a nuestro controlador de TrainerController, en nuestra funcion index() vamos a acceder al Request. Nuestra funcion index queda asi:
    public function index(Request $request)
    {
        $request->user()->authorizeRoles('admin');
        $trainers = Trainer::all();
        return view('trainers.index', compact('trainers')); //creado en el cap 17 para asignar la vista que ahora planeamos mostrar.
        
        //return 'Hola desde el controlador Trainers'; //Tuvo su uso en e cap 10 para probar que el controlador funcionaba 
    }
Donde con esta linea accedemos al "user" y le indicamos que verifique si tiene algun rol, que fue lo que declaramos en el modelo de User.php
    $request->user()->authorizeRoles('admin');
Para probar esto, nos logueamos con en usuario user que creamos cuando establecimos los seeder en el archivo:
    UserTableSeeder
Como sabemos el tiene rol de "User" y no de "admin", por lo que al refrescar la pagina de trainers le aparece una ventana de 404 unauthorized.
Ahora vamos a manejar una vista custom que muestr el mensaje de error de rol.
Vamos y creamos una vista en database/views y creamos una carpeta nueva llamada "errors", dentro de ella creamos un archivo llamado "401.blade.php" y alli dejamos la siguiente estructura:
    @extends('layouts.app')
    @section('content')
        <div class="container">
            <h1>This action is unauthorized</h1>
        </div> 
    @endsection
Ya una vez que el rol no es validado dara error "401".
38. Fix
Vamos a empezar areglando algunas cosas de la vista principal que se vieron afectadas en el capitulo 32 "Autenticacion" en donde al momento de inicializar nuestra logica de autenticacion pues esto genero que se sustituyera el archivo app.blade.php
En la linea 76 de nuestro archivo corregimos:
    <main class="container">
Tambien cuando iniciamos sesion nos manda a la vista "home" vamos a configurarlo para que nos muestre la vista de trainers, en app/http/Auth/Login....  Alli vamos a encontrar una variable protected llamada $redirectTo y encontramos una clase llamada RouteServiceProvider. Vemos que esta inicialmente haciendo mencion de: RouteServiceProvider::HOME y queremos cambiar eso a la vista trianers, pero en la clase RouteServiceProvider no existe aun una constante que haga referencia a dicha vista por ende debemos crearla:
    public const TRAINERS = '/trainers';
Una ve hecho esto volvemos a nuestro LoginController y hacemos referencia correctamente:
    protected $redirectTo = RouteServiceProvider::TRAINERS;
lo mismo podemos hacer en RegisterController.
39. Incorporando vue
Vue.js es un framework basado en JavaScript que nos ayudara a mejorar la forma en que generamos las vistas en nuestrsa aplicacion. Tambien pudimos implementar React.js pero en este caso sera hecho con Vue.js
Para implementar Vue en nuestra app podemos revisar que en el archivo package.json se encuentran las dependencias que podemos instalar. Para instalarlos ejecutamos en la consola:
    npm install
    Inmediatamente debemos ejecutar:
    npm run dev
    (tal como indica la documentacion de laravel: https://laravel.com/docs/6.x/frontend#writing-vue-components)
Una vez descargados e instalados podemos ya disponer de Vue.js en nuestra app.
Si chequeamos nuestra la carpeta resources/js encontraremos una carpeta llamada components alli Vue instalo un ejemplo. Y ya en nuestro archivo app.js vemos que se esta implementando:
    vease: linea 9 y 22.
En el archivo ExampleComponent.vue podemos ver la estructura fundamental de vue que es:
    template
    script   y 
    styles
Vamos a nuestra routes/web.php y agregamos:
    Route::resource('discipulos', 'DiscipuloController');
Como DiscipuloController no existe lo creamos por consola con ayuda de artisan:
    php artisan make:controller DiscipuloController
Al hacer el intento nos da un error, esto es porque en el archivo web.php de routes esta mal invocado la clase Route: (use Illuminate\Routing\Route;) y debe ser indicado de la siguiente forma (en la linea 14 de web.php):
    use Illuminate\Support\Facades\Route;
Dentro del controlador recien creado agregamos esto:
    public function index(){
        return view('discipulos.index');
    }
Ahora vamos a resources/views y creamos una carpeta para los discipulos
Dentro de esta carpeta vamos a agregar un archivo nuevo "index.blade.php" y alli lo que sigue:
    @extends('layouts.app')
    @section('content')
        <example-component>
        </example-component>
    @endsection
Ahora lo que vamos a hacer es usar el componente de ejemplo de vue para ver como se ve.
40. Listando recursos con Vue.js
Ahora vamos a crear un nuevo componente de vue para listar a los discipulos.
En resources/js/components creamos nuestro nuevo componente:
    DiscipulosComponent.vue
Alli (estoy trabajando con VSCode) con la ayuda de la extension "Vue VSCode Snippets" usamos vbase para generar la plantilla sencilla de vue.
Entre las etiquetas de "template" vamos a pegar la estructura que teniamos en trai/index.php
Dentro de "script" basta con colocar la sentencia export default y con ayuda de mounted() veremos en la consola cuando el componente este montado.
Ahora bien para agilizar nuestra ejecucuion de Vue.js en nuestro proyecto vamos a ejecutar en la consola 
    npm run watch
Y esto no es mas que ir compilando los archivos de Vue a medida que los vamos actualizando.
Debemos registrar nuestro componente en el archivo app.js que se encuentra en resorces/js
    Vue.component('discipulos-component', require('./components/DiscipulosComponent.vue').default);
y ademas debemos cambiar el componente requerido en index de "discipulos" por el de discipulos-component.
    @extends('layouts.app')
    @section('content')
        <discipulos-component>
            
        </discipulos-component>
    @endsection
Al final por el momento nuestro DiscipulosComponent.vue queda tanto el template como el script pereparados para luego indicar como vamos a consumir informacio para luego ir mostrando.
41. Peticion HTTP con Axios
Consumo de datos creados en nuestra aplicacion. Para poder hacer uso de nuestro Servicio es en ocasiones necesario contar con alguna libreria que nos permita realizar esta accion. Para ello vue nos sugieer usar Axios, que es un cliente HTTP basado en promesas:
    https://es.vuejs.org/v2/cookbook/using-axios-to-consume-apis.html
Vamos a incorporar axios a nuestro componente. DiscipulosComponent
Para ello vamos a usar mounted para hacer la peticion con axios. Axios ya esta instalado entre las dependencias instaladas que se puede verificar en nuestro package.json
    mounted() {
           axios.get('').then(response => (this.discipulos = response.data))
        }
Pero como vemos la peticion "get" no tiene a donde ser dirigida, por ello debemos entre los parametros del get decirle a que ruta va a enviar esa informacion. Para ello copiamos la direccion URL donde queremos pasar esa informacion quedando asi:
    axios.get('http://127.0.0.1:8000/discipulos').then(response => (this.discipulos = response.data))
Si verificamos nuestra vista hasta aqui vue "renderea" nuestra vista repitiendo un sin fin de "cards" que en realidad no tienen ningun dato en particular. Para solventar esto vamos  a el controlador de DiscipuloController:
        class DiscipuloController extends Controller
    {
        public function index(Request $request){
            if($request->ajax()){
                return response()->json([
                    ['id' => 1, 'name' => 'Juan']
                ]);
            }
            return view('discipulos.index');
        }
    }
Aqui simplemente "hardcodeamos" a un discipulo para que se pueda ver un card basado en ese dato json pero aun no estamos consumiendo de un archivo json en especifico.
Ahora si vamos a nuestro navegador en "Network" vemos las "Responses" de laravel veremos que nos esta respondiendo con un json.
Asi ya estamos mostrando informacion desde un "micro" servicio de laravel.
42.CSS Spinner
Normalmente cuando realizamos una aplicacion como esta que debe alimentarse de un servicio puede tardar un poco en mostrar la informacion, por ello hay que tener disponible una forma de mostrar al usuario que se esta esperando la informacion para que esta una vez este completamente disponible mostrarla al usuario.
Ahora vamos a implementar spinner en nuestra aplicacion, en el siguente enlace se pueden ver varios modelos de spinner que se pueden implementar:
    https://projects.lukehaas.me/css-loaders/
Ahora creamos un nuevo componente para el spinner. En resources/components.
Alli pegamos las estructuras para el spinner en nuestro component y luego lo registramos en la aplicacion en nuestro app.js
    Vue.component('spinner', require('./components/Spinner.vue').default);
Luego ingresamos la estiqueta que lleve por nombre segun lo hallamos indicado en nuestro app.js, en este caso la etiqueta sera <spinner>, y luego acomodamos el script:
    <script>
        export default {
            data(){
                return {
                    discipulos: [],
                    loading: true,
                }
            },
            mounted() {
            axios
                    .get('http://127.0.0.1:8000/discipulos')
                    .then((res) => {
                        this.discipulos = res.data
                        this.loading = false
                    })
            }
        }
    </script>
43. Store Laravel
Vamos a continuar con la creacion del discipulo. Una primera parte para poder crear un discipulos dentro del backend y luego crear las vistas para mostrar todo.
En la aplicacion aun no contamos con un modelo para discipulos.
En la terminal Ejecutamos para crear un modelo:
    php artisan make:model Discipulo -m
En el archivo recien creado ubicado eb database/migrations
    public function up()
    {
        Schema::create('discipulos', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->string('clase');
            $table->string('picture');
            $table->timestamps();
        });
    }
Ahora en la consola:
    php artisan migrate
Ahora trabajamos con el controlador de discipulo. Ahora nos vamos a enfocar en el metodo de almacenamiento. Creamos la siguiente funcion.
    public function store(Request $request){
        if($request->ajax()){
            $discipulo = new Discipulo();
            $discipulo->name = $request->input('name');
            $discipulo->clase = $request->input('clase');
            $discipulo->picture = $request->input('picture');
            $discipulo->save();

            return response()->json([
                "message" => "Discipulo Creado Correctamente"
            ], 200);
        }
    }
44. Discipulo component
Creamos un nuevo componente para crear un boton para crear un nuevo discipulo. En resources/js/components.
    AddDiscipuloComponent.vue
Agregamos este componente en nuestro archivo app.js
    Vue.component('add-discipulo-btn', require('./components/AddDiscipuloComponent.vue').default);
Y ahora lo embedbemos en nuestra vista index de discipulo:
    <add-discipulo-btn></add-discipulo-btn>
Ahora, actualmente el boton hace referencia a una modal llamado #addDiscipulo ahora vamos a crear el componente que ejecute esa creacion.
    CreateDiscipuloComponent.vue
Y alli dentro dejamos esto:
    <template>
    <div class="modal fade" id="addDiscipulo" role="dialog" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
        <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLabel">Agregar Discipulo</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
            </button>
        </div>
        <div class="modal-body">
            <form>
                <div class="form-group">
                    <label>Discipulo</label>
                    <input type="text" class="form-control" placeholder="Ingresa el nombre del Discipulo">
                </div>
                <div class="form-group">
                    <label>Clase del Discipulo</label>
                    <input type="text" class="form-control" placeholder="Ingresa la clase a la que pertenece">
                </div>
                <div class="form-group">
                    <label>Picture</label>
                    <input type="text" class="form-control" placeholder="Ingresa la url de una imagen" >
                </div>
                <button type="submit" class="btn btn-primary">Guardar</button>
            </form>
        </div>
        </div>
    </div>
    </div>
    </template>

    <script>
        export default {
            
        }
    </script>

    <style scoped>

    </style>
Ahora debemos resgitrar este nuevo componente en el archivo app.js
    Vue.component('create-form-discipulo', require('./components/CreateDiscipuloComponent.vue').default);
Y lo embedbemos en nuestro archivo index de discipulo:
    <create-form-discipulo></create-form-discipulo>
45. Creando Discipulo con Vue
Por ahora Vue aun no hace el trabajo de Binding de la informacion del discipulo. Para ello dentro de los input de captura de datos vamos a ingresar la siguiente clave de vue:
    v-model="nombre"
En la etiqueta general del form debemos detener el submit para poder manipularlo.
    <form @submit.prevent="saveDiscipulo">
Ahora en el script:
    <script>
        export default {
            data(){
                return {
                    name: null,
                    clase: null,
                    picture: null
                }
            },
            methods: {
                saveDiscipulo: function(){
                    axios.post('http://127.0.0.1:8000/discipulos', {
                        name: this.name,
                        clase: this.clase,
                        picture: this.picture
                    })
                    .then(function(res){
                        console.log(res)
                        $('addDiscipulo').modal('hide')
                    })
                    .catch(function(err){
                        console.log(err)
                    })
                    /* console.log(this.name)
                    console.log(this.clase)
                    console.log(this.picture) */
                }
            }
        }
    </script>
Debemos tener en cuenta que el URL una vez este en produccion esta debe cambiar, a la que hacemos referencia es:
    axios.post('http://127.0.0.1:8000/discipulos'
Notemos que:
    .then(function(res){
        console.log(res)
        $('addDiscipulo').modal('hide')
    })
Aqui manejamos la respuesta "res" response y ademas vamos a ocultar el modal de agregar discipulo.
En esta otra capturamos cualquier error y luego lo podemos manipular segun requeriramos:
    .catch(function(err){
        console.log(err)
    })
Ya con esto es suficiente para enviar toda la informacion al backend.
Muy importante antes de continuar debemos ir a nuestro DiscipuloController y hacer uso de la clase "Discipulo" porque sino dara error al tratar de registrar.
    use LaraPok\Discipulo;
Luego en ese mismo controlador debemos borrar la data que "harcodeamos" en capitulos anteriores y hacer esta vez el llamado correcto
Dentro del index creamos una consulta con Eloquent con el metodo all() nos traemos todos los discipulos almacenados.
    $discipulos = Discipulo::all();
    return response()->json($discipulos, 200);
Ahora en el componente de discipulos tenemos que hacer que se vea la imagen del Discipulo:
    v-bind:src="discipulo.picture" (debe borrarse el atributo src existente y sustituir por este)
Ademas se reacomodo la etiqueta div que contenia al v-for ya que una sugerencia de las extensiones de VSCode sugeria agregar un v-bind:key que no esta mal segun la informacion en la documentacion de Vue (https://es.vuejs.org/v2/guide/list.html):
    <div class="col-sm" v-for="discipulo in discipulos" v-bind:key="discipulo.id">
46. EventBus con Vue
Aqui vamos a tratar de corregir el hecho de que una vez agregado el discipulo la vista de los discipulos reaccione y nos lo muestre de una vez.
En nuestro controlador de discipulo, en la seccion donde almacenamos "store" algo que necesita nuestro cliente que en este caso es Vue es la informacion de ese nuevo discipulo que se esta agregando:
    return response()->json([
        "message" => "Discipulo Creado Correctamente",
        "discipulo" => $discipulo
    ], 200);
Queda asi. Ahora en el component de CreateDiscipuloComponent una vez creamos a un discipulo necesitamos usar EventBus que no es mas que decirle a un componente que escuche los eventos que sucedieron en otro componente, en nuestro caso queremos que CreateDiscipuloComponent le diga a DiscipulosComponent que se ha agregado un nuevo discipulo y por ende actualice la lista de discipulos.
El EventBus debo generarlo desde Vue y por ello debo crear un nuevo archivo en la carpeta raiz resources/js llamado event-bus.js
    window.Vue = require('vue');
    const bus = new Vue();

    export default bus
Incorporo a vue con window.Vue creamos una constante llamada bus que es un nuevo Vue y por ultimo lo exportamos por defecto.
Ahora en el CreateDiscipuloComponent lo primero en el script importamos el EventBus para usarlo
    import EventBus from '../event-bus';
Y ya lo podemos usar indicando que deseamos emitir dicho evento
    .then(function(res){
        console.log(res)
        $('#addDiscipulo').modal('hide')
        EventBus.$emit('discipulo-added', res.data.discipulo)
    })
Ahora en nuestro DiscipulosComponent debemos recibir dicho evento emitido, ahora vamos a trabajar con otro "livecycle" de vue llamado created():
    created(){
        EventBus.$on('discipulo-added', data => {
            this.discipulos.push(data)                
        })
    },
Si vemos un div llamado modal-backdrop no se ocultaba una vez enviado el formulario de registro de un discipulo, para forzarlo desde el CreateDiscipuloComponent forzamos el cierre de dicha clase en el .then con la siguiente instruccion:
    $('.modal-backdrop').remove()
47. Porque Vue?
Laravel nos provee de un par de dependencias con Bootstrap y Vue porque son muy usados en el regular de programacion de aplicaciones. Si vemos la documentacion de laravel vemos una intencion de laravel de poder hacer las aplicaciones mas reactivas, por ello incluyen a Vue como sugenerador reactivo y esto hace la aplicacion mas robusta. Es muy claro que las aplicaciones modernas desean que se desea que sea muy reactivo. Sin embargo laravel nos ofrece la posibilidad de remover el scaffolding de JavaScript. Y tambien si lo que queremos es usar React pues tambien podemos hacerlo sin problemas.
48. Refactor en componentes
Hemos ido creando componentes de forma desordenada simplemente para ver que estaban funcionales. Por ello vamos a organizarlos.
En resources/components creamos una carpeta adecuada para cada tipo de archivo que voy a estar tratando. Cree una carpeta 'discipulos' y otra carpeta 'widgets' 




Quede en el video #49 sin iniciar aun  de la serie: https://www.youtube.com/playlist?list=PLIddmSRJEJ0sxS-RmqdRMlkyWOQWvEGEt